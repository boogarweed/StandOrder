@page "/inventory"
@rendermode InteractiveServer
@using StandOrder.Models
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.EntityFrameworkCore
@inject AppDbContext db
@inject IJSRuntime JS

<h3>Inventory Adjustment</h3>

<div class="p-3 col-md-6">
    <div class="form-group mb-2">
        <label>Case Quantity:</label>
        <input type="number" class="form-control" @ref="caseQuantityInput" @bind="caseQuantity" disabled="@isBusy" placeholder="Enter case quantity" />
    </div>

    <div class="form-group mb-2">
        <label>Pack Quantity:</label>
        <input type="number" class="form-control" @bind="packQuantity" disabled="@isBusy" placeholder="Enter pack quantity" />
    </div>

    <div class="form-group mb-2">
        <label>Piece Quantity:</label>
        <input type="number" class="form-control" @bind="pieceQuantity" disabled="@isBusy" placeholder="Enter piece quantity" />
    </div>

    <div class="form-group mb-3">
        <label>Scan Barcode:</label>
        <input class="form-control"
               @ref="barcodeInput"
               @onkeydown="HandleScannerInput"
               @onkeydown:preventDefault="true"
               disabled="@isBusy" />
    </div>
</div>

@if (!string.IsNullOrEmpty(statusMessage))
{
    <div class="alert @(isError ? "alert-danger" : "alert-info") mt-3 col-md-6">@statusMessage</div>
}

@if (showProductSelectionModal)
{
    <div class="modal fade show" tabindex="-1" style="display: block; background-color: rgba(0,0,0,0.5);">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Multiple Products Found</h5>
                    <button type="button" class="btn-close" @onclick="CancelProductSelection" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <p>Please select the correct product for barcode '<strong>@scannedBarcode</strong>':</p>
                    <div class="list-group">
                        @foreach (var product in productsForSelection)
                        {
                            <button type="button" class="list-group-item list-group-item-action" @onclick="() => SelectProductFromModal(product)">
                                @product.ProductName
                            </button>
                        }
                    </div>
                </div>
            </div>
        </div>
    </div>
}
<script>
    window.clearBarcodeInput = (el) => { if(el) { el.value = ''; } };
</script>

@code {
    [Inject]
    private IDbContextFactory<AppDbContext> DbFactory { get; set; } = default!;

    // Scanning state
    string scannedBarcode = "";
    int? caseQuantity = null;
    int? packQuantity = null;
    int? pieceQuantity = null; // NEW: Backing field for Piece Quantity
    ElementReference barcodeInput;
    ElementReference caseQuantityInput;
    bool isBusy = false;
    string statusMessage = "";
    bool isError = false;

    // State for handling multiple products
    bool showProductSelectionModal = false;
    List<Product> productsForSelection = new();
    private System.Text.StringBuilder _scanBuffer = new();

    // Helper method to play sounds
    private async Task PlaySoundAsync(string soundFile)
    {
        await JS.InvokeVoidAsync("audioPlayer.play", soundFile);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await caseQuantityInput.FocusAsync();
        }
    }

    // Replaces HandleBarcodeKeyDown for better performance
    async Task HandleScannerInput(KeyboardEventArgs e)
    {
        if (e.Key == "Enter")
        {
            var code = _scanBuffer.ToString();
            _scanBuffer.Clear();
            await JS.InvokeVoidAsync("clearBarcodeInput", barcodeInput);

            if (isBusy || string.IsNullOrWhiteSpace(code)) return;

            isBusy = true;
            isError = false;
            StateHasChanged();

            try
            {
                // MODIFIED: Updated validation to include Piece Quantity
                if ((caseQuantity.GetValueOrDefault() <= 0) &&
                    (packQuantity.GetValueOrDefault() <= 0) &&
                    (pieceQuantity.GetValueOrDefault() <= 0))
                {
                    statusMessage = "Please enter a valid Case, Pack, or Piece quantity before scanning.";
                    isError = true;
                    await PlaySoundAsync("sounds/error.mp3");
                    return;
                }

                await using var db = DbFactory.CreateDbContext();
                var matchingProducts = await (
                    from b in db.Barcodes
                    join p in db.Products on b.UniversalItemNumber equals p.UniversalItemNumber
                    where b.BarCode == code
                       && p.ProductYear == DateTime.Now.Year.ToString()
                    select p
                ).ToListAsync();

                if (matchingProducts.Count == 1)
                {
                    await AdjustInventoryForProduct(matchingProducts.First());
                    await ResetInputsAndFocus();
                }
                else if (matchingProducts.Count > 1)
                {
                    scannedBarcode = code;
                    productsForSelection = matchingProducts;
                    showProductSelectionModal = true;
                    await PlaySoundAsync("sounds/attention.mp3");
                }
                else
                {
                    statusMessage = $"Product not found for barcode '{code}'.";
                    isError = true;
                    await PlaySoundAsync("sounds/error.mp3");
                    await ResetInputsAndFocus();
                }
            }
            catch (Exception ex)
            {
                statusMessage = $"An error occurred: {ex.Message}";
                isError = true;
            }
            finally
            {
                if (!showProductSelectionModal)
                {
                    isBusy = false;
                    StateHasChanged();
                }
            }
        }
        else if (e.Key.Length == 1)
        {
            _scanBuffer.Append(e.Key);
        }
    }

    async Task SelectProductFromModal(Product product)
    {
        showProductSelectionModal = false;
        try
        {
            await AdjustInventoryForProduct(product);
        }
        catch (Exception ex)
        {
            statusMessage = $"An error occurred: {ex.Message}";
            isError = true;
        }
        finally
        {
            await ResetInputsAndFocus();
            isBusy = false;
            StateHasChanged();
        }
    }

    async Task CancelProductSelection()
    {
        showProductSelectionModal = false;
        await ResetInputsAndFocus();
        isBusy = false;
        StateHasChanged();
    }

    // MODIFIED: This entire method has been updated for the new formula.
    async Task AdjustInventoryForProduct(Product product)
    {
        await using var db = DbFactory.CreateDbContext();
        var productToUpdate = await db.Products.FindAsync(product.ProductID);
        if (productToUpdate == null)
        {
            statusMessage = "Could not find the selected product in the database to update.";
            isError = true;
            return;
        }

        // Use GetValueOrDefault to safely handle null inputs (treats them as 0).
        var cq = caseQuantity.GetValueOrDefault();
        var pq = packQuantity.GetValueOrDefault();
        var iq = pieceQuantity.GetValueOrDefault();

        // NOTE: Assumes your Product model has 'PacksPerCase' and 'ItemsPerPack' properties.
        var packsPerCase = productToUpdate.PacksPerCase.GetValueOrDefault();
        var itemsPerPack = productToUpdate.ItemsPerPack.GetValueOrDefault();

        // Add validation to prevent calculation errors if product data is missing.
        if ((cq > 0 || pq > 0) && (packsPerCase <= 0 || itemsPerPack <= 0))
        {
            statusMessage = $"Product '{productToUpdate.ProductName}' is missing a valid 'PacksPerCase' or 'ItemsPerPack' value.";
            isError = true;
            await PlaySoundAsync("sounds/error.mp3");
            return;
        }

        // The new formula to calculate total individual pieces.
        int totalQuantity = (cq * packsPerCase * itemsPerPack) + (pq * itemsPerPack) + iq;

        // Update the 'QuantityInStock' (int) column instead of 'QtyInStock' (decimal).
        productToUpdate.QuantityInStock = totalQuantity;
        await db.SaveChangesAsync();

        // Update the success message for the new column and integer format.
        statusMessage = $"Successfully set '{productToUpdate.ProductName}' quantity to {productToUpdate.QuantityInStock}.";
        isError = false;
    }

    // MODIFIED: Clear the new piece quantity input.
    async Task ResetInputsAndFocus()
    {
        scannedBarcode = "";
        caseQuantity = null;
        packQuantity = null;
        pieceQuantity = null; // Reset piece quantity
        await caseQuantityInput.FocusAsync();
    }
}