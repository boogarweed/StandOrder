@rendermode InteractiveServer
@page "/receive-truck"
@using System.Collections.Concurrent
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.EntityFrameworkCore
@using StandOrder.Models
@inject IDbContextFactory<AppDbContext> DbFactory
@inject IJSRuntime JS
@implements IAsyncDisposable

<h3>Receive Truck</h3>

<div class="p-3">
    <div class="form-group mb-2">
        <label>Supplier:</label>
        <select class="form-control" @bind="selectedSupplierId" disabled="@isBusy">
            <option value="">-- Select supplier --</option>
            @foreach (var sup in suppliers)
            {
                <option value="@sup.SupplierID">@sup.SupplierName</option>
            }
        </select>
    </div>

    <div class="form-group mb-3">
        <label>Date Received:</label>
        <InputDate class="form-control" @bind-Value="receivedDate" disabled="@isBusy" />
    </div>

    <div class="form-group mb-2">
        <label>Quantity:</label>
        <InputNumber class="form-control" @bind-Value="currentQuantity" disabled="@isBusy" />
    </div>

    <div class="form-group mb-3">
        <label>Scan Barcode:</label>
        <input class="form-control"
               @ref="barcodeInput"
               @onkeydown="HandleScannerInput"
               @onkeydown:preventDefault="true" />
        @if (QueuedScanCount > 0)
        {
            <small class="form-text text-muted">Processing... (@QueuedScanCount in queue)</small>
        }
    </div>

    <script>
        window.standOrderStorage = {
            getTruckId: () => localStorage.getItem('truckId'),
            setTruckId: (id) => localStorage.setItem('truckId', id),
            clearTruckId: () => localStorage.removeItem('truckId')
        };

        window.clearBarcodeInput = (el) => { if(el) { el.value = ''; } };
    </script>

    <h4 class="mt-3">Received Items</h4>
    <ul class="list-group mb-3">
        @foreach (var item in receivedProducts)
        {
            <li class="list-group-item d-flex justify-content-between align-items-center">
                <div class="d-flex flex-column">
                    <span class="fw-bold">@item.ProductName</span>
                    <small class="text-muted">ID: @item.ProductID</small>
                </div>
                <div>
                    <span class="badge bg-primary rounded-pill me-2">
                        @item.QuantityReceived
                    </span>
                    <button class="btn btn-sm btn-danger"
                            @onclick="() => RemoveReceived(item)" disabled="@isBusy">
                        Remove
                    </button>
                </div>
            </li>
        }
    </ul>

    <button class="btn btn-success" @onclick="HandleSubmit" disabled="@isBusy">
        Submit Receipt
    </button>
</div>

@if (!string.IsNullOrEmpty(statusMessage))
{
    <div class="alert @statusMessageClass mt-3">@statusMessage</div>
}

@if (showProductSelectionModal)
{
    <div class="modal fade show" tabindex="-1" style="display: block; background-color: rgba(0,0,0,0.5);">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Multiple Products Found</h5>
                    <button type="button" class="btn-close" @onclick="CancelProductSelection" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <p>Please select the correct product for barcode '<strong>@scannedBarcode</strong>':</p>
                    <div class="list-group">
                        @foreach (var product in productsForSelection)
                        {
                            <button type="button" class="list-group-item list-group-item-action" @onclick="() => SelectProductFromModal(product)">
                                @product.ProductName
                            </button>
                        }
                    </div>
                </div>
            </div>
        </div>
    </div>
}

@code {
    // Loaded once
    List<Supplier> suppliers = new();
    int? selectedSupplierId;
    DateTime receivedDate = DateTime.Now;

    // Scanning state
    string scannedBarcode = "";
    int currentQuantity = 1;
    ElementReference barcodeInput;
    bool isBusy = false;

    // Draft-truck tracking
    int? draftTruckId;
    List<ReceivedProductViewModel> receivedProducts = new();
    string statusMessage = "";
    string statusMessageClass = "alert-info";

    // Product Selection Modal state
    bool showProductSelectionModal = false;
    List<Product> productsForSelection = new();
    private (string Barcode, int Quantity)? _pendingSelectionScan;

    // --- Queueing and Background Processing State ---
    private readonly ConcurrentQueue<(string Barcode, int Quantity)> _scanQueue = new();
    private readonly CancellationTokenSource _cts = new();
    private Task? _processingTask;
    private SemaphoreSlim _signal = new SemaphoreSlim(0);
    private System.Text.StringBuilder _scanBuffer = new();
    public int QueuedScanCount => _scanQueue.Count;

    private async Task PlaySoundAsync(string soundFile)
    {
        await JS.InvokeVoidAsync("audioPlayer.play", soundFile);
    }

    protected override async Task OnInitializedAsync()
    {
        await using var db = DbFactory.CreateDbContext();
        suppliers = await db.Suppliers.OrderBy(s => s.SupplierName).ToListAsync();
        _processingTask = ProcessScanQueueAsync(_cts.Token);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await barcodeInput.FocusAsync();
            var stored = await JS.InvokeAsync<string>("standOrderStorage.getTruckId");
            if (int.TryParse(stored, out var tid))
            {
                isBusy = true;
                StateHasChanged();
                try
                {
                    await using var db = DbFactory.CreateDbContext();
                    draftTruckId = tid;
                    var truck = await db.Trucks.FindAsync(tid);
                    if (truck != null)
                    {
                        selectedSupplierId = truck.SupplierID;
                        receivedDate = truck.ReceivedDate;

                        var details = await (from tp in db.TruckProducts
                                             join p in db.Products on tp.ProductID equals p.ProductID
                                             where tp.TruckID == tid
                                             select new ReceivedProductViewModel
                                             {
                                                 ProductID = tp.ProductID,
                                                 ProductName = p.ProductName,
                                                 QuantityReceived = tp.QuantityReceived
                                             }).ToListAsync();
                        receivedProducts = details;
                    }
                }
                finally
                {
                    isBusy = false;
                    StateHasChanged();
                }
            }
        }
    }

    private async Task HandleScannerInput(KeyboardEventArgs e)
    {
        if (e.Key == "Enter")
        {
            var code = _scanBuffer.ToString();
            _scanBuffer.Clear();
            await JS.InvokeVoidAsync("clearBarcodeInput", barcodeInput);

            if (string.IsNullOrWhiteSpace(code)) return;

            if (selectedSupplierId == null)
            {
                statusMessage = "Please select a supplier before scanning.";
                statusMessageClass = "alert-warning";
                await PlaySoundAsync("sounds/error.mp3");
                StateHasChanged();
                return;
            }

            _scanQueue.Enqueue((code, currentQuantity));
            _signal.Release();

            ResetForNextScan();
            await barcodeInput.FocusAsync();
        }
        else if (e.Key.Length == 1)
        {
            _scanBuffer.Append(e.Key);
        }
    }

    private async Task ProcessScanQueueAsync(CancellationToken token)
    {
        while (!token.IsCancellationRequested)
        {
            await _signal.WaitAsync(token);
            if (token.IsCancellationRequested) break;

            while (_scanQueue.TryDequeue(out var scan))
            {
                isBusy = true;
                await InvokeAsync(StateHasChanged);

                try
                {
                    await ProcessSingleScan(scan);
                }
                catch (Exception ex)
                {
                    statusMessage = $"Error processing {scan.Barcode}: {ex.Message}";
                    statusMessageClass = "alert-danger";
                }
                finally
                {
                    isBusy = showProductSelectionModal;
                    await InvokeAsync(StateHasChanged);
                }
            }
        }
    }

    private async Task ProcessSingleScan((string Barcode, int Quantity) scan)
    {
        statusMessage = "";
        scannedBarcode = scan.Barcode;

        if (draftTruckId == null)
        {
            await CreateDraftTruckAsync();
        }

        await using var db = DbFactory.CreateDbContext();

        var matchingProducts = await (
            from b in db.Barcodes
            join p in db.Products on b.UniversalItemNumber equals p.UniversalItemNumber
            where b.BarCode == scan.Barcode && p.ProductYear == DateTime.Now.Year.ToString()
            select p
        ).ToListAsync();

        if (matchingProducts.Count == 1)
        {
            await AddProductToReceipt(matchingProducts.First(), scan.Quantity);
        }
        // ▼▼▼▼▼ ANNOTATED CHANGE START ▼▼▼▼▼
        else if (matchingProducts.Count > 1)
        {
            var firstUIN = matchingProducts.First().UniversalItemNumber;

            bool allHaveSameUIN = matchingProducts.All(p => p.UniversalItemNumber == firstUIN);

            if (allHaveSameUIN)
            {
                await AddProductToReceipt(matchingProducts.First(), scan.Quantity);
            }
            else
            {
                _pendingSelectionScan = scan;
                productsForSelection = matchingProducts;
                showProductSelectionModal = true;
                await PlaySoundAsync("sounds/attention.mp3");
            }
        }
        // ▲▲▲▲▲ ANNOTATED CHANGE END ▲▲▲▲▲
        else
        {
            statusMessage = $"Product not found for '{scan.Barcode}'.";
            statusMessageClass = "alert-warning";
            await PlaySoundAsync("sounds/error.mp3");
        }
    }


    async Task SelectProductFromModal(Product product)
    {
        showProductSelectionModal = false;
        if (_pendingSelectionScan.HasValue)
        {
            await AddProductToReceipt(product, _pendingSelectionScan.Value.Quantity);
            _pendingSelectionScan = null;
        }
        isBusy = false;
        await InvokeAsync(StateHasChanged);
        await barcodeInput.FocusAsync();
    }

    async Task CancelProductSelection()
    {
        showProductSelectionModal = false;
        _pendingSelectionScan = null;
        statusMessage = "Scan canceled.";
        statusMessageClass = "alert-info";
        isBusy = false;
        await InvokeAsync(StateHasChanged);
        await barcodeInput.FocusAsync();
    }

    async Task AddProductToReceipt(Product product, int quantityToAdd)
    {
        await using var db = DbFactory.CreateDbContext();

        var trackedProduct = await db.Products.FindAsync(product.ProductID);
        if (trackedProduct == null) return;

        trackedProduct.QtyInStock += quantityToAdd;

        var existing = receivedProducts.FirstOrDefault(x => x.ProductID == product.ProductID);
        if (existing != null)
        {
            existing.QuantityReceived += quantityToAdd;
            receivedProducts.Remove(existing);
            receivedProducts.Insert(0, existing);
            statusMessage = $"Updated {product.ProductName}: qty {existing.QuantityReceived}";
            statusMessageClass = "alert-success";

            var dbItem = await db.TruckProducts.FirstAsync(tp => tp.TruckID == draftTruckId && tp.ProductID == product.ProductID);
            dbItem.QuantityReceived = existing.QuantityReceived;
        }
        else
        {
            receivedProducts.Insert(0, new ReceivedProductViewModel
            {
                ProductID = product.ProductID,
                ProductName = product.ProductName,
                QuantityReceived = quantityToAdd
            });
            statusMessage = $"Added {product.ProductName}";
            statusMessageClass = "alert-success";

            db.TruckProducts.Add(new TruckProducts
            {
                TruckID = draftTruckId.Value,
                ProductID = product.ProductID,
                QuantityReceived = quantityToAdd
            });
        }
        await db.SaveChangesAsync();
    }

    void ResetForNextScan()
    {
        currentQuantity = 1;
    }

    async Task HandleSubmit()
    {
        if (isBusy) return;

        if (draftTruckId == null)
        {
            statusMessage = "Nothing to submit.";
            statusMessageClass = "alert-warning";
            return;
        }

        isBusy = true;

        try
        {
            statusMessage = $"Truck {draftTruckId} finalized with {receivedProducts.Count} items.";
            statusMessageClass = "alert-success";

            await JS.InvokeVoidAsync("standOrderStorage.clearTruckId");

            draftTruckId = null;
            receivedProducts.Clear();
            selectedSupplierId = null;
            ResetForNextScan();
        }
        finally
        {
            isBusy = false;
        }

        StateHasChanged();
    }

    async Task CreateDraftTruckAsync()
    {
        if (selectedSupplierId == null)
            throw new InvalidOperationException("Must select supplier before scanning.");

        await using var db = DbFactory.CreateDbContext();

        var truck = new Truck
        {
            SupplierID = selectedSupplierId.Value,
            ReceivedDate = receivedDate.Date
        };
        db.Trucks.Add(truck);
        await db.SaveChangesAsync();

        draftTruckId = truck.TruckID;
        await JS.InvokeVoidAsync("standOrderStorage.setTruckId", draftTruckId.Value);
    }

    async Task RemoveReceived(ReceivedProductViewModel item)
    {
        if (isBusy) return;
        isBusy = true;

        try
        {
            await using var db = DbFactory.CreateDbContext();

            var product = await db.Products.FindAsync(item.ProductID);
            if (product != null)
            {
                product.QtyInStock -= item.QuantityReceived;
            }

            receivedProducts.Remove(item);
            if (draftTruckId != null)
            {
                var dbItem = await db.TruckProducts
                    .SingleOrDefaultAsync(tp => tp.TruckID == draftTruckId && tp.ProductID == item.ProductID);

                if (dbItem != null)
                {
                    db.TruckProducts.Remove(dbItem);
                    await db.SaveChangesAsync();
                }
            }
        }
        finally
        {
            isBusy = false;
        }
    }

    public async ValueTask DisposeAsync()
    {
        _cts.Cancel();
        _signal.Release();
        if (_processingTask != null)
        {
            await _processingTask;
        }
        _cts.Dispose();
        _signal.Dispose();
    }

    class ReceivedProductViewModel
    {
        public int ProductID { get; set; }
        public string ProductName { get; set; }
        public int QuantityReceived { get; set; }
    }
}